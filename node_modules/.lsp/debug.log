Hello - from /Users/mandalarian/.vscode/extensions/jaredly.reason-vscode-1.7.8/bin.native
Previous log location: /var/folders/rt/7lc5vcw16459dszl8djk35fh0000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":true,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml","languageId":"ocaml","version":1,"text":"(*Generated by Lem from semantics.lem.*)\nopen Smoosh\n\nopen Fields (* late stage expansion *)\nopen Arith\nopen Pattern\nopen Command\n\n(*import Debug*)\n\n(**********************************************************************)   \n(* SHARED DECLARATIONS FOR EXPANSION AND EVALUATION *******************)   \n(**********************************************************************)   \n\n(* TECHNICAL DEBT 2019-03-04 just have an opts record *)\n\ntype string_mode =\n    UserString\n  | GeneratedString\n\ntype quoting_mode =\n    Unquoted\n  | Quoted\n\ntype 'a redir_exp_result =\n    REDone of 'a * expanded_redir\n  | REError of fields\n  | REStep of expansion_step * 'a * expanding_redir\n\n(*val expand_control : forall 'a. OS 'a => \n                     os_state 'a -> splitting_mode -> quoting_mode -> control ->\n                     either (expansion_step * os_state 'a * expanded_words) \n                            (expansion_step * os_state 'a * expanded_words * words)*) \n(*val expand_words : forall 'a. OS 'a => \n                   os_state 'a -> splitting_mode -> quoting_mode -> string_mode -> \n                   (expanded_words * words) ->\n                   either (expansion_step * os_state 'a * expanded_words) \n                          (expansion_step * os_state 'a * expanded_words * words)*) \n(*val step_expansion : forall 'a. OS 'a =>\n                     os_state 'a * expansion_state -> \n                     expansion_step * os_state 'a * expansion_state*) \n(*val step_redir : forall 'a. OS 'a => \n                   os_state 'a -> expanding_redir -> redir_exp_result (os_state 'a)*)\n(*val step_redir_state : forall 'a. OS 'a => os_state 'a -> redir_state -> \n                       os_state 'a * string * maybe (redir_state * maybe expansion_step)*)\n(*val check_traps : forall 'a. OS 'a => evaluation_step * os_state 'a * stmt -> evaluation_step * os_state 'a * stmt*)\n(*val expansion_error : forall 'a. OS 'a => bool (* may exit? *) -> os_state 'a -> evaluation_step -> expansion_step -> fields ->  evaluation_step * os_state 'a * stmt*) \n(*val step_eval : forall 'a. OS 'a => step_fun 'a*) (* see os.lem for defn *)\n\n(*val full_evaluation : forall 'a. OS 'a => os_state 'a -> stmt -> os_state 'a*)\n(*val eval : forall 'a. OS 'a => os_state 'a -> stmt -> nat*)\n\n(**********************************************************************)   \n(* TRAP MANAGEMENT ****************************************************)   \n(**********************************************************************)   \n\nlet rec internal_check_traps dict_Os_OS_a step s0 c:evaluation_step*'a os_state*stmt=\n   ((match pending_signal \n  dict_Os_OS_a s0 with\n  | (s1, None) -> (step, s1, c)\n  | (s1, Some signal1) ->\n     (match Pmap.lookup signal1 s1.sh.traps with\n     | None -> internal_check_traps \n  dict_Os_OS_a step s1 c\n     | Some ss_handler ->\n        let (s2,_,s_handler) = (concretize s1 ss_handler) in\n        let src = (ParseString( ParseTrap, s_handler)) in\n        let sstr = (Shim.parse_init src) in\n        let c_handler =                    \n          (EvalLoop( 1, (sstr, Some (Dash.init_stack ())), src, \n            Noninteractive, Subsidiary))\n        in\n        (XSNested( (XSTrap( signal1, \"trapped\")), step), \n         s2, \n         Trapped( signal1, s2.sh.exit_code, c_handler, c))\n     )\n  ))\n\nlet check_traps dict_Os_OS_a res:evaluation_step*'a os_state*stmt=\n   ((match res with\n  | (_,_,Exit) -> res\n  | (step0,s0,c0) -> \n     let s1 = (log_trace \n  dict_Os_OS_a Trace_traps \"checked traps\" s0) in\n     (internal_check_traps \n  dict_Os_OS_a step0 s1 c0)\n  ))\n\nlet expansion_error dict_Os_OS_a may_exit s0 evalstep expstep err:evaluation_step*'a os_state*stmt=\n   (let msg = (string_of_symbolic_string (symbolic_string_of_fields err)) in\n  let s1 = (fail_with \n  dict_Os_OS_a msg s0) in\n  check_traps dict_Os_OS_a ((XSExpand( evalstep, expstep)),\n               s1,\n               (if may_exit && is_interactive s1 then Done else Exit)))\n\n(**********************************************************************)   \n(* EXPANSION **********************************************************)   \n(**********************************************************************)   \n   \n(*\n * Stage 1 Expansion: Word expansion\n *)\n\n(*val expand_param : forall 'a. OS 'a => os_state 'a -> splitting_mode -> quoting_mode -> string -> format -> os_state 'a * expanded_words * words*)\n\n(* TODO 2017-12-01\n * In an N____ case, when null_string fs is Nothing, the\n * string is entirely symbolic so we need\n * to represent the symbolic result of \"it could be either\n * true or false, we don't know\". This means we need to branch\n * and allow for both cases to progress.\n *)\nlet expand_param dict_Os_OS_a s0 split1 q str f:'a os_state*(expanded_word)list*(entry)list=\n   (\n  (* return type says we yield `expanded_words * words`, but really\n     only one or the other these functions package up the possible\n     bits of logic *)let (s1, value) =\n    (if (str = \"*\") && ((q = Quoted) || not (should_split split1))\n    then \n      let (s1, sep) = \n        ((match lookup_string_param s0 \"IFS\" with\n        | None -> (s0,[C ' '])\n        | Some ss ->\n           let (s1,_,ifs) = (concretize s0 ss) in\n           (match Xstring.explode ifs with\n           | [] -> (s1, [])\n           | c::_ -> (s1, [C c])\n           )\n        )) \n      in\n      (s1, Some [symbolic_string_of_fields_sep sep (get_function_params s1)])\n    else\n      (s0, lookup_param s0 str))\n  in\n  let cstr s=   (s1, [ExpS s], []) in\n  let ewfs fs1=  (s1, expanded_words_of_fields fs1, []) in\n  let wrds w=   (s1, [], w) in\n  let null ()=  (s1, [], []) in\n  let ctrl k=   (s1, [], [K k]) in\n  let unst o= \n      (if not (elem instance_Basic_classes_Eq_string_dict str [\"@\"; \"*\"]) && Pset.mem Sh_nounset s0.sh.opts \n    then ctrl (LError( str, [ExpS \"parameter not set\"], []))\n    else o)\n  in\n  (match (value, f) with\n  (* NORMAL *)\n  | (None, Normal)     -> unst (null ()) (* unset, no field *)\n  | (Some fs1, Normal)     -> ewfs fs1\n  (* DEFAULT *)\n  | (None, Default w)  -> wrds w\n  | (Some fs1, Default _)  -> ewfs fs1\n  | (None, NDefault w) -> wrds w\n  | (Some fs1, NDefault w) ->\n     (match null_fields fs1 with\n     | None -> \n        let s2 = (log_trace \n  dict_Os_OS_a Trace_symbolic \"Unsoundly treating symbolic fields as non-empty\" s1) in\n        (s2, expanded_words_of_fields fs1, [])\n     | Some true -> wrds w\n     | Some false -> ewfs fs1\n     )\n  (* ASSIGN *)\n  | (None, Assign w)  -> ctrl (LAssign( str, [], w))\n  | (Some fs1, Assign _)  -> ewfs fs1       \n  | (None, NAssign w) -> ctrl (LAssign( str, [], w))\n  | (Some fs1, NAssign w) -> \n     (match null_fields fs1 with\n     | None -> ewfs fs1\n     | Some true -> ctrl (LAssign( str, [], w))\n     | Some false -> ewfs fs1\n     )\n  (* ERROR *)\n  | (None, Error w)  -> ctrl (LError( str, [], w))\n  | (Some fs1, Error _)  -> ewfs fs1\n  | (None, NError w) -> ctrl (LError( str, [], w))\n  | (Some fs1, NError w) -> \n     (match null_fields fs1 with\n     | None -> \n        let s2 = (log_trace \n  dict_Os_OS_a Trace_symbolic \"Unsoundly treating symbolic fields as non-empty\" s1) in\n        (s2, expanded_words_of_fields fs1, [])\n     | Some true -> ctrl (LError( str, [], w))\n     | Some false -> ewfs fs1\n     )\n  (* LENGTH *)\n  | (None, Length) -> unst (cstr \"0\")\n  | (Some fs1, Length) ->\n     (* TODO 2018-10-08 need to return a new state to support logging of concretization *)\n     (match try_concrete_fields fs1 with\n     | None -> (* TODO This should be the length of the symbolic result of fs *) cstr \"0\"\n     | Some strs -> cstr (string_of_int (String.length strs))\n     )\n  (* ALT *)\n  | (None, Alt _)  -> null ()\n  | (Some _, Alt w)  -> wrds w\n  | (None, NAlt _) -> null ()\n  | (Some fs1, NAlt w) ->\n     (match null_fields fs1 with\n     | None -> \n        let s2 = (log_trace \n  dict_Os_OS_a Trace_symbolic \"Unsoundly treating symbolic fields as non-empty\" s1) in\n        (s2, [], w)\n     | Some true -> null ()\n     | Some false -> wrds w\n     )\n  (* SUBSTRINGS (prefix/suffix) *)\n  | (None, Substring( _, _, _)) -> unst (cstr \"\")\n  | (Some fs1, Substring( s, m, w)) -> ctrl (LMatch( fs1, s, m, [], w))\n  ))\n\nlet rec expand_control dict_Os_OS_a s0 split1 q k:((expansion_step*'a os_state*(expanded_word)list),(expansion_step*'a os_state*(expanded_word)list*(entry)list))Either.either=\n     ((match k with\n    | Tilde prefix -> \n       if prefix = \"\"\n       then let (s1, dir) = \n                ((match lookup_concrete_param s0 \"HOME\" with\n                (* if HOME is unset, results are unspecified---we return \"~\" \n                   dash:\n                     $ unset HOME\n                     $ echo ~\n                     ~\n                     $ HOME=\"\"\n                     $ echo ~\n                     ~\n                     $ HOME=\"/Users/mgree\"\n                     $ echo ~\n                     /Users/mgree\n                   \n                   bash:\n                     $ unset HOME\n                     $ echo ~\n                     /Users/mgree\n                     $ HOME=\"\"\n                     $ echo ~\n                     \n                     $ HOME=\"/Users/mgree\"\n                     $ echo ~\n                     /Users/mgree            \n                   \n                   lol\n                *)\n                | None -> \n                   (log_trace \n  dict_Os_OS_a Trace_unspec \n                      \"unset HOME for ~ (unspec per 2.6.1)\" s0, \n                    ExpS \"~\")\n                | Some dir -> (s0, DQuo (symbolic_string_of_string dir))\n              )) in\n              Either.Right (ESTilde \"\", s1, [dir], [])\n         else\n           (match getpwnam \n  dict_Os_OS_a s0 prefix with\n           | None ->\n              (* unspec per 2.6.1, but we follow dash *)\n              let s1 = (log_trace \n  dict_Os_OS_a Trace_unspec\n                         (\"defaulting to dash behavior for failed getpwnam \" ^\n                              \"(unspec per 2.6.1)\")\n                         s0) \n              in\n              Either.Right (ESTilde \"\", s1, [ExpS (\"~\" ^ prefix)], []) \n           | Some path1 -> Either.Right (ESTilde \"\", s0, [ExpS path1], [])\n           )\n    | Param( s, f) -> \n       (* We special case logic for \"$@\" here. The rest is in expand_param. *)\n       if (s = \"@\") && (q = Quoted)\n       then \n         let param_vars = (get_function_params s0) in\n         (* -, = and ? can adhere when no params set\n            + should always just expand the words, since $@ is never unset/null\n            # should expand everything, convert to a string, and count. same as *.\n            %/%% operates on the last param and #/## on the first param (in dash)\n          *)\n         let unspec =\n           ((match f with\n           | Length -> true\n           | Substring( _, _, _) -> true\n           | _ -> false\n           ))\n         in\n         let s1 =\n           (if unspec \n           then log_trace \n  dict_Os_OS_a Trace_unspec \n                  (\"Unspecified parameter format: \" ^ string_of_control (Param( s, f)))\n                  s0\n           else s0)\n         in\n         let expand_more w=  (expand_words \n  dict_Os_OS_a s1 split1 q GeneratedString ([],w)) in\n         let build_at v=  (Either.Right (ESParam \"expanding @\", s1, [At v], [])) in\n         (match f with\n         | Default _ -> build_at param_vars\n         | NDefault w ->\n            if list_null param_vars\n            then expand_more w\n            else build_at param_vars\n         | Assign _ -> build_at param_vars\n         | NAssign _ -> \n            if list_null param_vars\n            then expand_more [K (LError( \"@\", [ExpS \"bad variable name\"], []))]\n            else build_at param_vars\n         | Error _ -> build_at param_vars\n         | NError w ->\n            if list_null param_vars\n            then expand_more [K (LError( \"@\", [], w))]\n            else build_at param_vars\n         | Length -> expand_more [K (Param( \"*\", Length))]\n         | Alt w -> expand_more w\n         | NAlt w -> \n            if list_null param_vars\n            then build_at param_vars\n            else expand_more w\n         | Substring( Prefix, mode, w) -> \n            (match param_vars with\n            | v1::vars -> \n               let v1' = (K (Quote( [], [K (LMatch( [v1], Prefix, mode, [], w))]))) in\n               expand_more (v1'::words_of_fields vars)\n            | _ -> build_at []\n            )\n         | Substring( Suffix, mode, w) ->\n            (match dest_init param_vars with\n            | Some (vars', vn) -> \n               let vn' = (K (Quote( [], [K (LMatch( [vn], Suffix, mode, [], w))]))) in\n               expand_more ( List.rev_append (List.rev (words_of_fields vars')) [vn'])\n            | None -> build_at []\n            )\n         | _ -> build_at param_vars\n         )\n       else \n         let (s1, ew, w) = (expand_param \n  dict_Os_OS_a s0 split1 q s f) in\n         expand_words \n  dict_Os_OS_a s1 split1 q GeneratedString (ew, w)\n    | LAssign( s, f, []) ->\n       (match set_param \n  dict_Os_OS_a s (concat_expanded f) s0 with\n       | Either.Left err -> Either.Left (ESParam \"bad or readonly variable\", s0, (ExpS err::f))\n       | Either.Right s1 -> Either.Right (ESParam \"finished assignment\", s1, f, [])\n       )\n    | LAssign( s, f, w) ->\n       (match expand_words \n  dict_Os_OS_a s0 NoSplit q GeneratedString ([], w) with\n       | Either.Right (step, s1, f1, w1) ->\n          Either.Right (ESNested( (ESParam \"assignment\"), step), \n                 s1, [], [K (LAssign( s, ( List.rev_append (List.rev f) f1), w1))])\n       | Either.Left err -> Either.Left err\n       )\n    | LMatch( str, side, mode, f, []) -> \n       let sympat = (symbolic_string_of_expanded_words false (* lowkey for pattern... but don't munge quotes *) f) in\n       let symstr = (symbolic_string_of_fields str) in\n       let (s1,_concretized,pat) = (concretize s0 sympat) in\n       let matched = (try_match_substring s1.sh.locale side mode pat symstr) in\n       Either.Right (ESParam \"finished match\", \n              s1, [], \n              words_of_symbolic_string matched)\n    | LMatch( s, side, mode, f, w) ->\n       (match expand_words \n  dict_Os_OS_a s0 NoSplit q GeneratedString ([], w) with\n       | Either.Right (step, s1, f1, w1) -> \n          Either.Right (ESNested( (ESParam \"match\"), step), \n                 s1, [], [K (LMatch( s, side, mode, ( List.rev_append (List.rev f) f1), w1))])\n       | Either.Left err -> Either.Left err\n       )\n    | LError( str, f, []) -> \n       (* dash seems to print erroring variable name; TODO should we also have linno? *)\n       Either.Left (ESParam \"raising requested error\", s0, (ExpS (str ^ \": \")::f)) \n    | LError( str, f, w) ->\n       (match expand_words \n  dict_Os_OS_a s0 NoSplit q GeneratedString ([], w) with\n       | Either.Right (step, s1, f1, w1) -> \n          Either.Right (ESNested( (ESParam \"error\"), step), \n                 s1, [], [K (LError( str, ( List.rev_append (List.rev f) f1), w1))])\n       | Either.Left err -> Either.Left err\n       )\n    | Backtick c ->\n       (* create a pipe *)\n       let (s1, fd_read, fd_write) = (pipe \n  dict_Os_OS_a s0) in\n       let cmd1 = \n         (* set up redirects [skipping expansion] *)\n         (with_redirs c [ERDup( ToFD, CloseOrig, sTDOUT, (Some fd_write));\n                         ERDup( ToFD, CloseOrig, fd_read, None)])\n       in\n       let (s2, pid1) = \n         (fork_and_subshell \n  dict_Os_OS_a s1 cmd1 \n           FG None (* no pgid *) false) (* no job control *) \n       in\n       let s3 = (close_fd \n  dict_Os_OS_a s2 fd_write) in\n       Either.Right (ESCommand \"initializing subshell\", \n              s3,\n              [], \n              [K (LBacktick( c, pid1, fd_read))])\n    | LBacktick( corig, pid1, fd_read) ->\n        (match read_all_fd \n  dict_Os_OS_a  (step_eval dict_Os_OS_a) s0 fd_read with\n        | (s1, Either.Left step) ->\n           Either.Right (ESEval( (ESCommand (\"process with pid \" ^ (string_of_int pid1 ^ \" stepped\"))),\n                    step),\n                  s1,\n                  [],\n                  [K (LBacktick( corig, pid1, fd_read))])\n        | (s1, Either.Right None) -> \n           Either.Left (ESCommand \"broken pipe\",\n                 s1,\n                 [])\n        | (s1, Either.Right (Some s)) ->\n           (* \"If the output contains any null bytes, the behavior is\n              unspecified.\"\n\n              \"Any valid shell script can be used for command, except a\n              script consisting solely of redirections which produces\n              unspecified results.\"\n\n            *)\n           let s2 = (close_fd \n  dict_Os_OS_a s1 fd_read) in\n           let s_trimmed = (trimr_newlines s) in\n           (* \"If there is no command name, but the command contained\n              a command substitution, the command shall complete with\n              the exit status of the last command substitution\n              performed.\" *)\n           Either.Right (ESCommand \"command exited successfully, waiting\",\n                  s2, \n                  [], \n                  [K (LBacktickWait( corig, pid1, s_trimmed))])\n        )\n    | LBacktickWait( corig, pid1, s) ->\n        (match wait_for_pid \n  dict_Os_OS_a  (step_eval dict_Os_OS_a) s0 pid1 with\n        | (s1, None) ->\n           Either.Right (ESCommand \"command process vanished, leaving exit code unset\",\n                  s1,\n                  [ExpS s],\n                  [])\n        | (s1, Some (Either.Left step)) ->\n           Either.Right (ESEval( (ESCommand \"command process stepped\"), step),\n                  s1,\n                  [],\n                  [K (LBacktickWait( corig, pid1, s))])\n        | (s1, Some (Either.Right code)) ->\n           Either.Right (ESCommand \"command process terminated\",\n                  exit_with code s1,\n                  [ExpS s],\n                  [])\n        )\n    | Arith( f, []) ->\n        (match arith64 \n  dict_Os_OS_a s0 (concat_expanded f) with\n        | Either.Right (s1, result) -> \n           Either.Right (ESArith \"computed arithmetic result\", \n                  s1, expanded_words_of_fields result, [])\n        | Either.Left e -> Either.Left (ESArith \"arithmetic error\", s0, [ExpS e])\n        )\n    | Arith( f, w) ->\n       (match expand_words \n  dict_Os_OS_a s0 split1 q GeneratedString ([],w) with\n       | Either.Right (step, s1, f1, w1) -> \n          Either.Right (ESNested( (ESArith \"before arithmetic parsing\"), step), \n                 s1, [], [K (Arith( ( List.rev_append (List.rev f) f1), w1))])\n       | Either.Left err -> Either.Left err\n        )\n   | Quote( f, []) ->\n      Either.Right (ESQuote \"finished quote expansion\", \n             s0, collapse_quoted f, [])\n   | Quote( f, w) -> \n       (match expand_words \n  dict_Os_OS_a s0 split1 Quoted GeneratedString ([],w) with\n       | Either.Right (step, s1, [], w1) ->\n          (* special case for null fields... avoids QRK_EMPTPPWRD\n\n             set --\n             x=\"\"\n             set -- \"$x$@$x\"\n             echo $# \n             \n             should yield 1\n           *)\n          Either.Right (step, s1, [], [K (Quote( ( List.rev_append (List.rev f) [DQuo []]), w1))])\n       | Either.Right (step, s1, f1, w1) -> \n          Either.Right (step, s1, [], [K (Quote( ( List.rev_append (List.rev f) f1), w1))])\n       | Either.Left err -> Either.Left err\n       )\n  ))\n\nand expand_words dict_Os_OS_a s0 split1 q sm (f,w):((expansion_step*'a os_state*(expanded_word)list),(expansion_step*'a os_state*(expanded_word)list*(entry)list))Either.either=\n   ((match w with\n    | [] -> Either.Right (ESStep \"done\", s0, f, w)\n    | F::ws -> Either.Right (ESStep \"user field separator\", s0,  List.rev_append (List.rev f) [UsrF], ws)\n    | S \"\"::ws -> expand_words \n  dict_Os_OS_a s0 split1 q sm (f,ws)\n    | S s ::ws ->\n       let f1 = ((match (q, sm) with\n         | (Quoted, _) -> [DQuo (symbolic_string_of_string s)]\n         | (Unquoted, UserString) -> [UsrS s]\n         | (Unquoted, GeneratedString) -> [ExpS s]\n       )) in\n       Either.Right (ESStep \"plain string\", s0,  List.rev_append (List.rev f) f1, ws)\n    | K k::ws ->\n       (match expand_control \n  dict_Os_OS_a s0 split1 q k with\n       | Either.Right (step, s1, f1, w1) -> Either.Right (step, s1, List.rev_append (List.rev f) f1, ( List.rev_append (List.rev w1) ws))\n       | Either.Left err -> Either.Left err\n       )\n    | ESym c::ws -> Either.Right (ESStep \"skipping symbolic result\", s0,  List.rev_append (List.rev f) [EWSym c], ws)\n  ))\n\n(**********************************************************************)\n(* EXPANSION TRANSITIONS **********************************************)\n(**********************************************************************)\n\n (* TECHNICAL DEBT 2019-03-04\n\n   There are a variety of ways to run only part of expansion.\n\n   dash accomplishes this with a variety of flags.\n\n   we have a variety of ad hoc ways (boolean flags, interrupting\n    stepping)\n\n   can we make this uniform? how many different ways of expanding are\n    there, really?\n *)\n (* TECHNICAL DEBT 2019-03-04\n\n    ExpExpand below is _visible_ it steps to a final state before\n    transitioning to the next stage of expansion. Plenty of bits of\n    expansion/evaluation have the opportunity for visibility, but most\n    of our step relations do some invisible work.\n\n    It's probably better if _everything_ is made visible.\n  *)\n\nand step_expansion dict_Os_OS_a (os0,st):expansion_step*'a os_state*expansion_state=\n   ((match st with\n  | ExpStart( opts1, w0) -> \n     (match expand_words \n  dict_Os_OS_a os0 opts1.splitting Unquoted UserString ([],w0) with\n     | Either.Right (step, os1, f1, w1) -> (step, os1, ExpExpand( opts1, f1, w1))\n     | Either.Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))\n     )\n  | ExpExpand( opts1, f0, []) ->\n     if should_split opts1.splitting\n     then (ESSplit \"starting field splitting\", os0, ExpSplit( opts1, f0))\n     else (ESSplit \"skipping field splitting\", os0, ExpPath( opts1, (skip_field_splitting f0)))\n  | ExpExpand( opts1, f0, w0) -> \n     (match expand_words \n  dict_Os_OS_a os0 opts1.splitting Unquoted UserString (f0,w0) with\n     | Either.Right (step, os1, f1, w1) -> (step, os1, ExpExpand( opts1, f1, w1))\n     | Either.Left (step, os1, f1) -> (step, os1, ExpError (fields_of_expanded_words f1))\n     )\n  | ExpSplit( opts1, f0) -> (ESSplit \"\", os0, ExpPath( opts1, (field_splitting \n  dict_Os_OS_a os0 f0)))\n  | ExpPath( opts1, ifs0) -> \n     if Pset.mem Sh_noglob os0.sh.opts || (opts1.globbing = false)\n     then (ESPath \"skipping pathname expansion (set -f/assignment/etc.)\", os0, \n           ExpQuote( opts1, (unescape_intermediate_fields ifs0)))\n     else (ESPath \"\", os0, ExpQuote( opts1, (pathname_expansion \n  dict_Os_OS_a os0 ifs0)))\n  | ExpQuote( _opts, ifs0) -> (ESQuote \"\", os0, ExpDone (quote_removal ifs0))\n  (* the following cases should never occur in calls from trace_expansion: *)\n  | ExpError _ -> (ESStep \"done in error state\", os0, st)\n  | ExpDone _ -> (ESStep \"done in success state\", os0, st)\n  ))\n\n(**********************************************************************)   \n(* EVALUATION *********************************************************)   \n(**********************************************************************)   \n   \n(* Steps an expanding_redir along *)\nand step_redir dict_Os_OS_a os0 er:('a os_state)redir_exp_result=\n   (let exp_state = (get_expanding_redir_state er) in\n  let (step, os1, st1) = (step_expansion \n  dict_Os_OS_a (os0, exp_state)) in\n  (match st1 with\n   | ExpError err -> REError err\n   | ExpDone f -> \n      (match try_expand_redir er f with\n      | Either.Left err -> REError [symbolic_string_of_string err]\n      | Either.Right er' -> REDone( os1, er')\n      )\n   | ExpPath( opts1, ifs) ->\n      (* \"Pathname expansion shall not be performed on the word [that\n         is the target of redirection] by a non-interactive shell; an\n         interactive shell may perform it, but shall do so only when\n         the expansion would result in one word.\"\n\n        \"If no part of word is quoted, all lines of the here-document\n         shall be expanded for parameter expansion, command\n         substitution, and arithmetic expansion.\"\n\n         i.e., skipping pathname expansion. the dash parser should\n         take care of a lot of this. \n       *)\n      let (msg,es') = \n        (if is_interactive os1 && (not (is_heredoc er) && opts1.globbing)\n        then \n          let expanded = (pathname_expansion \n  dict_Os_OS_a os1 ifs) in\n          if List.length expanded = 1\n          then (\"performed pathname expansion in interactive shell\",\n                ExpQuote( opts1, expanded))\n          else ((\"skipped pathname expansion in interactive shell [produced \" ^ \n                ((string_of_int (List.length expanded)) ^ \" words]\")),\n                ExpQuote( opts1, (unescape_intermediate_fields ifs)))\n        else if is_heredoc er\n        then (\"stopping expansion for heredoc\", ExpQuote( opts1, (unescape_heredoc ifs)))\n        else (\"skipped pathname expansion\", ExpQuote( opts1, (unescape_intermediate_fields ifs))))\n      in\n      REStep( (ESPath msg), os1, (set_expanding_redir_state es' er))\n   | _ -> REStep( step, os1, (set_expanding_redir_state st1 er))\n   ))\n\nand step_redir_state dict_Os_OS_a os0 redir_state1:'a os_state*string*(((expanded_redir)list*(expanding_redir)option*(redir)list)*(expansion_step)option)option=\n   ((match redir_state1 with\n  | (_ers, None, []) -> (os0, \"done expanding redirs\", Some (redir_state1, None))\n  | (ers, None, r::redirs) ->\n     let opts1 = ({ splitting = NoSplit; globbing = (is_interactive os0) }) in\n     let (msg, ers, exp_state) =\n       ((match r with\n       | RFile( ty, src, w) -> (\"expanding file redirect\", ers, Some (XRFile( ty, src, (ExpStart( opts1, w)))))\n       | RDup( ty, src, w) -> (\"expanding dup redirect\", ers, Some (XRDup( ty, src, (ExpStart( opts1, w)))))\n       | RHeredoc( XHere, src, w) -> \n          (\"expanding unquoted heredoc\", ers, Some (XRHeredoc( XHere, src, (ExpStart( opts1, w)))))\n       | RHeredoc( Here, src, w) -> \n          (\"not expanding quoted heredoc\",  \n           List.rev_append (List.rev ers) [ERHeredoc( Here, src, (symbolic_string_of_string (string_of_words w)))], \n           None)\n       )) in\n     (os0, msg, Some ((ers, exp_state, redirs), None))\n  | (ers, Some er, redirs) ->\n     (match step_redir \n  dict_Os_OS_a os0 er with\n     | REError err ->\n        let msg = (string_of_symbolic_string (symbolic_string_of_fields err)) in\n        (os0,\n         msg,\n         None)\n     | REDone( os1, er') ->\n        (os1,\n         \"expanded redirect\",\n         Some (( List.rev_append (List.rev ers) [er'], None, redirs), None))\n     | REStep( step, os1, er') ->\n        (os1,\n         \"redirection expansion step\",\n         Some ((ers, Some er', redirs), Some step))\n     )\n  ))\n\nand step_eval dict_Os_OS_a s0 checked stmt1:evaluation_step*'a os_state*stmt=\n   (\n  (* \n     extremely subtle behavior with errors in expansion:\n       an expansion error is NOT a field\n       expansion errors cancel the current command with a failing exit status\n\n     $ count() { echo $# ; }\n     $ count ${x?one two three}                            # never runs count\n     /Users/mgree/smoosh/dash/src/dash: 2: x: one two three\n     $ count $(echo ${x?one two three})                    # subshell fails, but count will run!\n     /Users/mgree/smoosh/dash/src/dash: 2: x: one two three\n     0\n     $ count $(echo ${x?one two three} four)\n     /Users/mgree/smoosh/dash/src/dash: 3: x: one two three\n     0\n     $ count $(echo ${x?one two three}) four\n     /Users/mgree/smoosh/dash/src/dash: 4: x: one two three\n     1\n     $ count $(${x? one two three}) four\n     /Users/mgree/smoosh/dash/src/dash: 5: x:  one two three\n  *)(match stmt1 with\n  (* COMMAND ******************************************************************)\n  | Command( assigns, ws, redirs, opts1) ->\n     (XSSimple \"expand command args\",\n      s0,\n      CommandExpArgs( \n        assigns, \n        (ExpStart( { splitting = Split; globbing = true }, ws)),\n        redirs,\n        opts1))\n\n  | CommandExpArgs( assigns, exp_state, redirs, opts1) ->\n      let (step, s1, st1) = (step_expansion \n  dict_Os_OS_a (s0, exp_state)) in\n      (match st1 with\n        | ExpError err -> expansion_error \n  dict_Os_OS_a true (* may exit *) s1 (XSSimple \"arg expansion\") step err\n        | ExpDone f ->\n           let msg = \n             (string_of_int (List.length f) ^ (\" \" ^ (if List.length f = 1 then \"argument\" else \"arguments\" ^ \n             \" fully expanded (including command)\")))\n           in\n           (XSExpand( (XSSimple msg), step), \n            s1, \n            CommandExpRedirs( assigns, f, ([], None, redirs), opts1))\n        | _ ->\n           (XSExpand( (XSSimple \"argument expansion step\"), step),\n            s1,\n            CommandExpArgs( assigns, st1, redirs, opts1))\n      )\n\n   (* done expanding redirs *)\n   | CommandExpRedirs( assigns, args, (ers, None, []), opts1) ->\n     let (s1, prog_special) = \n       ((match args with\n       | s_prog::_ ->\n          let (s1, _, prog_name) = (concretize s0 s_prog) in\n          (s1, is_special_builtin prog_name)\n       | _ -> (s0, false)\n       ))\n     in\n     let catching_errors = (not (checked_exit checked) && Pset.mem Sh_errexit s1.sh.opts) in\n     let exit_on_error = \n       (catching_errors ||\n       (prog_special && \n        (not opts1.force_simple_command && \n        not (is_interactive s1)))) (* per table in 2.8.1 *)\n     in\n     (match do_redirs \n  dict_Os_OS_a s1 ers with\n     | (s2, Either.Left msg) ->\n        check_traps dict_Os_OS_a\n          (XSSimple (\"error in redirection: \" ^ msg), \n           fail_with dict_Os_OS_a msg s2,\n           (if exit_on_error then Exit else Done))\n     | (s2, Either.Right saved_fds1) ->\n        let exp_assigns = \n          (map (fun (x, w) -> \n              (x, ExpStart( { splitting = NoSplit; globbing = false }, w))) \n            assigns)\n        in\n        (* initialize local scope for assignments \n\n           using a new local scope means that every expansion step can see these new locals\n           we'll pop the scope before running whatever command we see\n         *)\n        let s3 = (new_local_scope s2) in\n        (XSSimple \"redirected; expanding assignments\",\n         s3,\n         CommandExpAssign( exp_assigns, args, saved_fds1, opts1))\n     )\n\n   (* expand redirs *)\n   | CommandExpRedirs( assigns, args, redir_state1, opts1) ->\n      (match step_redir_state \n  dict_Os_OS_a s0 redir_state1 with\n      | (s1, msg, None) ->\n         let (s2, may_exit) =\n           ((match args with\n           | ss_prog::_ ->\n              let (s2, _, prog) = (concretize s1 ss_prog) in\n              (s2, is_special_builtin prog)\n           | _ -> (s1, false)\n           ))\n         in\n         expansion_error \n  dict_Os_OS_a may_exit s2 (XSSimple \"error in redirect expansion\") (ESStep \"\") \n           [symbolic_string_of_string msg]\n      | (s1, msg, Some (redir_state', mstep)) ->\n         let (ran_cmd_subst', step) =\n           ((match mstep with\n           | Some estep -> ((opts1.ran_cmd_subst || ran_command_substitution estep),\n                            XSExpand( (XSSimple msg), estep))\n           | None -> (opts1.ran_cmd_subst, XSSimple msg)\n         )) in\n         let opts' = ({ opts1 with ran_cmd_subst = ran_cmd_subst' }) in\n         (step, s1,\n          CommandExpRedirs( assigns, args, redir_state', opts'))\n      )\n\n  (* expanding assignments *)      \n  | CommandExpAssign( ((x,exp_state0)::assigns), args, saved_fds1, opts1) ->\n     let (step, s1, exp_state1) = (step_expansion \n  dict_Os_OS_a (s0, exp_state0)) in\n     let opts' = ({ opts1 with\n         ran_cmd_subst = (opts1.ran_cmd_subst || ran_command_substitution step)\n       })\n     in\n     (match exp_state1 with\n     | ExpDone f ->\n        (* write the to our outer local scope *)\n        (match force_local_param s1 x (symbolic_string_of_fields f) with\n        | Either.Left err -> \n           (* OVERFIT\n              PENDING CONFIRMATION 2019-06-07 \n              we should always exit \n            *)\n           let special_or_assign =\n             ((match args with\n             | cmd1::_ -> is_special_builtin (string_of_symbolic_string cmd1) &&\n                           not (opts1.force_simple_command)\n             | [] -> true\n             ))\n           in\n           let may_exit =\n             ((not (checked_exit checked) && Pset.mem Sh_errexit s1.sh.opts) || \n             not (is_interactive s1)) \n           in\n           let s2 = (safe_write_stderr \n  dict_Os_OS_a (err ^ \"\\n\") s1) in\n           (XSSimple \"assignment error\", exit_with 2 s2,\n            (if special_or_assign && may_exit \n            then Exit\n            else Done))\n        | Either.Right s2 ->\n           (XSSimple (\"assign \" ^ x), s2,\n            CommandExpAssign( assigns, args, saved_fds1, opts'))\n        )\n     | ExpError err -> \n        expansion_error \n  dict_Os_OS_a true (* may exit *) s1 (XSSimple \"assignment expansion\") step err\n     | _ -> \n        (XSExpand( (XSSimple \"\"), step),\n         s1, \n         CommandExpAssign( ((x,exp_state1)::assigns), args, saved_fds1, opts'))\n     )\n\n  (* we're done expanding assignments. do we have a command? *)\n  | CommandExpAssign( [], args, saved_fds1, opts1) ->\n     (* save our accumulated locals.\n\n        we can ignore any options set on these variables, becuase\n        assignments all happen in subshells and couldn't change things\n        anyway.\n\n        we can similarly ignore empty entries, which can only come\n        from the `local` builtin (as run in a subshell)\n      *)\n     let (s1, local_env1) = (pop_locals s0) in\n     let assigns =\n       (Pmap.bindings_list (Lem_map_extra.option_map \n  (instance_Map_MapKeyType_var_dict instance_Basic_classes_SetType_var_dict) (fun _x (m_v, _opts) -> m_v) local_env1))\n     in\n     (match args with\n     | [] ->\n       (* we're done expanding assignments and there's no command \n          all local assignments are done, just need to restore fds from redirs \n     \n          \"If there is no command name, but the command contained a command\n          substitution, the command shall complete with the exit status of\n          the last command substitution performed. Otherwise, the command\n          shall complete with a zero exit status\"\n        *)\n       let s2 = (restore_fds \n  dict_Os_OS_a s1 saved_fds1) in\n       let s3 = \n         (if opts1.ran_cmd_subst\n         then s2\n         else exit_with 0 s2)\n       in\n       (* we've already called check_param in force_local_param *)\n       let s4 = (List.fold_right (fun (x,v) os -> checked_set_param \n  dict_Os_OS_a x v os) assigns s3) in\n       (* announce what we've done if `set -x` *)\n       let trace =\n         (concat \" \" (map (fun (x,v) -> x ^ (\"=\" ^ string_of_symbolic_string v)) assigns))\n       in\n       let s5 = (xtrace \n  dict_Os_OS_a trace s4) in\n       (XSSimple \"finished assignments w/o command, popping redirects\",\n        s5,\n        Done)\n     | cmd1::argv ->\n       (* we have commands---let's go! *)\n        (XSSimple \"assignments fully expanded\",\n         s1,\n         CommandReady( assigns, cmd1, argv, saved_fds1, opts1))\n     )\n\n  (* COMMAND: ready ***************************************************)\n  (* expansion is done, try to run command *)\n  | (CommandReady( assigns, prog, args, saved_fds1, opts1) as cmd1) ->\n     if Pset.mem Sh_noexec s0.sh.opts\n     then (XSSimple \"set -n: skipping command\", s0, Done)\n     else\n     let s0_traced = (xtrace \n  dict_Os_OS_a (string_of_stmt cmd1) s0) in\n     (* \"If the command name is a special built-in utility, variable\n        assignments shall affect the current execution environment.\"\n\n        Unless the set -a option is on (see set), it is unspecified:\n\n        Whether or not the variables gain the export attribute during\n        the execution of the special built-in utility\n\n        Whether or not export attributes gained as a result of the\n        variable assignments persist after the completion of the\n        special built-in utility\n\n        If the command name is a function that is not a standard\n        utility implemented as a function, variable assignments shall\n        affect the current execution environment during the execution\n        of the function. It is unspecified:\n\n        Whether or not the variable assignments persist after the\n        completion of the function\n\n        Whether or not the variables gain the export attribute during\n        the execution of the function\n\n        Whether or not export attributes gained as a result of the\n        variable assignments persist after the completion of the\n        function (if variable assignments persist after the completion\n        of the function)\n\n        If any of the variable assignments attempt to assign a value\n        to a variable for which the readonly attribute is set in the\n        current shell environment (regardless of whether the\n        assignment is made in that environment), a variable assignment\n        error shall occur. See Consequences of Shell Errors for the\n        consequences of these errors.\n\n        *)\n     let (s0_logged, concretized, prog_name) = (concretize s0_traced prog) in\n     let prog_special = (is_special_builtin prog_name) in\n     let s1 = \n       (if not concretized && (prog_special && not opts1.force_simple_command)\n       then\n         (* need a call to set_param, which has the right logic for\n            Sh_allexport.\n\n            NB that check_param has already been called during assignments\n          *)\n         List.fold_right (fun (x,v) os -> checked_set_param \n  dict_Os_OS_a x v os) assigns s0_logged\n       else s0_logged)\n     in\n     let catching_errors = \n       (not (checked_exit checked) && Pset.mem Sh_errexit s1.sh.opts) \n     in\n     let exit_on_error = \n       (catching_errors ||\n       (prog_special && \n        (not opts1.force_simple_command && \n        not (is_interactive s1)))) (* per table in 2.8.1 *)\n     in\n     (* load exported variables, perform assignments *)\n     let env1 = (Lem_map.fromList \n  (instance_Map_MapKeyType_var_dict instance_Basic_classes_SetType_var_dict) assigns) in\n     (match run_command \n  dict_Os_OS_a s1 opts1 checked prog args env1 with\n     | Either.Right (s2, stmt', restore) -> \n        (XSSimple (\"ran \" ^ string_of_symbolic_string prog), \n         s2, \n         (if catching_errors && not (s2.sh.exit_code = 0)\n         then Exit\n         else if restore \n         then pushredir stmt' saved_fds1 \n         else stmt'))\n     | Either.Left (s2,msg) -> \n        check_traps dict_Os_OS_a\n          (XSSimple \"couldn't run command\", \n           fail_with dict_Os_OS_a (string_of_symbolic_string prog ^ (\": \" ^ msg)) s2, \n           (if exit_on_error \n           then Exit \n           else pushredir Done saved_fds1))\n     )\n\n  (* PIPE *********************************************************************)\n  | Pipe( bg_mode1, stmts) ->\n     let (s1, pipeline1, last_pid1) = (run_pipe \n  dict_Os_OS_a s0 stmts bg_mode1) in\n     let (s2, c) =\n       (let (s2, _job) = (add_job \n  dict_Os_OS_a s1 pipeline1 last_pid1 (Pipe( bg_mode1, stmts)) bg_mode1 JobRunning) in\n       if is_bg bg_mode1\n       then (set_last_pid last_pid1 s2, Done)\n       else \n         (* If the pipeline is not in the background (see Asynchronous\n            Lists), the shell shall wait for the last command\n            specified in the pipeline to complete, and may also wait\n            for all commands to complete. *)\n         (s2, Wait( last_pid1, checked, None, WaitInternal))) \n     in\n     check_traps dict_Os_OS_a (XSPipe \"started pipe\", s2, c)\n\n  (* REDIR ********************************************************************)\n  | Redir( stmt', (ers, None, [])) ->\n     check_traps dict_Os_OS_a \n       ((match do_redirs \n  dict_Os_OS_a s0 ers with\n        | (s1, Either.Left msg) -> \n           (XSRedir \"error in redirection\", \n            fail_with \n  dict_Os_OS_a msg s1, \n            Done)\n        | (s1, Either.Right saved_fds1) ->\n           (XSRedir \"running redirected command\", \n            s1, \n            pushredir stmt' saved_fds1)\n        ))\n  (* redirection steps *)\n  | Redir( stmt', redir_state1) ->\n     (match step_redir_state \n  dict_Os_OS_a s0 redir_state1 with\n     | (s1, msg, None) ->\n        check_traps dict_Os_OS_a\n            (XSRedir \"error in redirect expansion\", \n              fail_with \n  dict_Os_OS_a msg s1, \n              Done)\n     | (s1, msg, Some (redir_state', mstep)) ->\n        let step =\n          ((match mstep with\n          | Some estep -> XSExpand( (XSRedir msg), estep)\n          | None -> XSRedir msg\n          )) in\n        (step, s1, Redir( stmt', redir_state'))\n     )\n\n  (* BACKGROUND ***************************************************************)\n  | Background( stmt', (((ers, None, []) as redir_state1))) ->\n     let redir_state' =\n       (if not (is_monitoring s0) && not (List.exists expanded_redir_has_stdin_redir ers)\n       then\n         (* If job control is disabled (see set, -m), the standard input\n            for an asynchronous list, before any explicit redirections\n            are performed, shall be considered to be assigned to a file\n            that has the same properties as /dev/null. This shall not\n            happen if job control is enabled. In all cases, explicit\n            redirection of standard input shall override this\n            activity. *)\n         (* TODO 2019-04-11 make /dev/null path configurable *)\n         ((ERFile( From, 0, (symbolic_string_of_string \"/dev/null\"))::ers), None, [])\n       else redir_state1)\n     in\n     (* defer to Redir to load redirs *)\n     let (s1,pid1) = \n       (fork_and_subshell \n  dict_Os_OS_a s0 (Redir( stmt', redir_state')) \n         BG None (* no pgid *) true) (* job control possible? *)\n     in\n     let (s2, _job) = (add_job \n  dict_Os_OS_a s1 [(pid1, Background( stmt', redir_state1))] (* unit pipeline *)\n                        pid1 (Background( stmt', redir_state1) (* don't show our munging *)) BG JobRunning) in\n     let s3 = (set_last_pid pid1 s2) in\n     check_traps dict_Os_OS_a\n       (XSBackground (\"started background process with pid \" ^ \n                        (string_of_int pid1)), \n        s3, \n        Done)\n  (* expand redirs *)\n  | Background( stmt', redir_state1) ->\n     (match step_redir_state \n  dict_Os_OS_a s0 redir_state1 with\n     | (s1, msg, None) ->\n        check_traps dict_Os_OS_a\n          (XSBackground \"error in redirect expansion\", \n           fail_with dict_Os_OS_a msg s1, \n           Done)\n     | (s1, msg, Some (redir_state', mstep)) ->\n        let step =\n          ((match mstep with\n          | Some estep -> XSExpand( (XSBackground msg), estep)\n          | None -> XSBackground msg\n          )) in\n        (step, s1, Background( stmt', redir_state'))\n     )\n \n  (* SUBSHELL *****************************************************************)\n  | Subshell( stmt', (((_, None, []) as redir_state1))) ->\n     let base_c = (Redir( stmt', redir_state1)) in\n     let checked_c = (if checked_exit checked then CheckedExit base_c else base_c) in\n     let (s1,pid1) = \n       (fork_and_subshell \n  dict_Os_OS_a s0 checked_c\n         FG None (* no pgid *) true) (* job control possible? *)\n     in\n     check_traps dict_Os_OS_a\n       (XSSubshell (\"started subshell with pid \" ^ string_of_int pid1), \n        s1, \n        Wait( pid1, checked, None, WaitInternal))\n\n  | Subshell( stmt', redir_state1) ->\n     (match step_redir_state \n  dict_Os_OS_a s0 redir_state1 with\n     | (s1, msg, None) ->\n        check_traps dict_Os_OS_a\n          (XSSubshell \"error in redirect expansion\", \n           fail_with dict_Os_OS_a msg s1, \n           Done)\n     | (s1, msg, Some (redir_state', mstep)) ->\n        let step =\n          ((match mstep with\n          | Some estep -> XSExpand( (XSSubshell msg), estep)\n          | None -> XSSubshell msg\n          )) in\n        (step, s1, Subshell( stmt', redir_state'))\n     )\n\n  (* AND **********************************************************************)\n  | And( l, r) ->\n     let (step, s1, l') = (step_eval \n  dict_Os_OS_a s0 Checked l)  in\n     (match l' with\n      | Exit       -> (step, s1, Exit)\n      | Return     -> (step, s1, Return)\n      | Break n    -> (step, s1, Break n)\n      | Continue n -> (step, s1, Continue n)\n      | Done ->\n         check_traps dict_Os_OS_a\n           (if s1.sh.exit_code = 0\n            then (XSAnd \"exit code was 0, continuing\", s1, r)\n            else (XSAnd \"exit code was non-zero, short-circuiting\", s1, Done))\n      | _ -> (XSNested( (XSAnd \"\"), step), s1, And( l', r))\n      )\n\n  (* OR ***********************************************************************)\n  | Or( l, r) ->\n     let (step, s1, l') = (step_eval \n  dict_Os_OS_a s0 Checked l)  in\n     (match l' with\n      | Exit       -> (step, s1, Exit)\n      | Return     -> (step, s1, Return)\n      | Break n    -> (step, s1, Break n)\n      | Continue n -> (step, s1, Continue n)\n      | Done ->\n         check_traps dict_Os_OS_a\n           (if s1.sh.exit_code = 0\n            then (XSOr \"exit code was 0, short-circuiting\", s1, Done)\n            else  (XSOr \"exit code was non-zero, continuing\", s1, r))\n      | _ -> (XSNested( (XSOr \"\"), step), s1, Or( l', r))\n      )\n\n  (* NOT **********************************************************************)\n  | Not stmt' ->\n     let (step, s1, stmt'') = (step_eval \n  dict_Os_OS_a s0 Checked stmt') in\n     (match stmt'' with\n     | Exit       -> (step, s1, Exit)\n     | Return     -> (step, s1, Return)\n     | Break n    -> (step, s1, Break n)\n     | Continue n -> (step, s1, Continue n)\n     | Done ->\n        check_traps dict_Os_OS_a\n          (if s1.sh.exit_code = 0\n           then (XSNot \"0 -> 1\", exit_with 1 s1, Done)\n           else (XSNot \"!0 -> 0\", exit_with 0 s1, Done))\n     | _ -> (XSNested( (XSNot \"\"), step), s1, Not stmt'')\n     )\n\n  (* SEMI *********************************************************************)\n  | Semi( l, r) ->\n     let (step, s1, l') = (step_eval \n  dict_Os_OS_a s0 checked l) in\n     (match l' with\n     | Exit       -> (step, s1, Exit)\n     | Return     -> (step, s1, Return)\n     | Break n    -> (step, s1, Break n)\n     | Continue n -> (step, s1, Continue n)\n     | Done       -> check_traps \n  dict_Os_OS_a (XSNested( (XSSemi \"done with LHS\"), step), s1, r)\n     | _          -> (XSNested( (XSSemi \"\"), step), s1, Semi( l', r))\n     )\n\n  (* IF ***********************************************************************)\n  | If( c, t, e) ->\n     let (step, s1, c') = (step_eval \n  dict_Os_OS_a s0 Checked c) in\n     (match c' with\n     | Exit       -> (step, s1, Exit)\n     | Return     -> (step, s1, Return)\n     | Break n    -> (step, s1, Break n)\n     | Continue n -> (step, s1, Continue n)\n     | Done ->\n        check_traps dict_Os_OS_a\n          (if s1.sh.exit_code = 0\n           then (XSIf \"exit code was 0, taking the true branch\", s1, t)\n           else (XSIf \"exit code was non-zero, taking the false branch\", s1, e))\n     | _ -> (XSNested( (XSIf \"\"), step), s1, If( c', t, e))\n      )\n\n  (* WHILE ********************************************************************)\n  | While( c, body) -> \n     (XSWhile \"start to evaluate the condtion\", \n      enter_loop s0, \n      WhileCond( c, c, body, None))\n  | WhileCond( c, cur, body, saved_ec) ->\n     let (step, s1, cur') = (step_eval \n  dict_Os_OS_a s0 Checked cur) in\n     (match cur' with\n     | Exit       -> (XSNested( (XSWhile \"exiting\"), step), s1, Exit)\n     | Return     -> (XSNested( (XSWhile \"returning\"), step), s1, Return)\n     | Break 1    -> (XSNested( (XSWhile \"breaking\"), step), exit_loop s1, Done)\n     | Break n    -> (XSNested( (XSWhile \"breaking to outer loop\"), step), \n                      exit_loop s1, Break (Nat_num.nat_monus n 1))\n     | Continue 1 -> (XSNested( (XSWhile \"continuing loop\"), step), \n                       s1, WhileCond( c, c, body, saved_ec))\n     | Continue n -> (XSNested( (XSWhile \"continuing to outer loop\"), step), \n                      exit_loop s1, Continue (Nat_num.nat_monus n 1))\n     | Done ->\n        check_traps dict_Os_OS_a\n          (if s1.sh.exit_code = 0\n           then (XSWhile \"exit code was 0, running the loop body\", \n                 s1, WhileRunning( c, body, body))\n           else\n             let ec =\n               ((match saved_ec with\n               | None -> 0\n               | Some ec -> ec\n               ))\n             in\n             (XSWhile \"exit code was non-zero, taking the false branch\", \n              exit_with ec (exit_loop s1), Done))\n      | _ -> (XSNested( (XSWhile \"\"), step), s1, WhileCond( c, cur', body, saved_ec))\n      )\n  | WhileRunning( c, body, cur) ->\n     let (step, s1, cur') = (step_eval \n  dict_Os_OS_a s0 checked cur)  in\n     (match cur' with\n      | Exit       -> (XSNested( (XSWhile \"exiting\"), step), s1, Exit)\n      | Return     -> (XSNested( (XSWhile \"returning\"), step), s1, Return) \n      | Break 1    -> (XSNested( (XSWhile \"breaking loop\"), step), exit_loop s1, Done)\n      | Break n    -> (XSNested( (XSWhile \"breaking to outer loop\"), step), exit_loop s1, Break (Nat_num.nat_monus n 1))\n      | Continue 1 -> (XSNested( (XSWhile \"continuing loop\"), step), s1, WhileCond( c, c, body, (Some s1.sh.exit_code)))\n      | Continue n -> (XSNested( (XSWhile \"continuing to outer loop\"), step), exit_loop s1, Continue (Nat_num.nat_monus n 1))\n      | Done       -> check_traps \n  dict_Os_OS_a (XSNested( (XSWhile \"finished iteration of while loop; retesting condition\"), step), s1, WhileCond( c, c, body, (Some s1.sh.exit_code)))\n      | _          -> (XSNested( (XSWhile \"\"), step), s1, WhileRunning( c, body, cur'))\n      )\n\n  (* FOR **********************************************************************)\n  | For( var, ws, body) -> (XSFor \"begin arg expansion\", s0, ForExpArgs( var, (ExpStart( { splitting = Split; globbing = true }, ws)), body))\n  | ForExpArgs( var, exp_state, body) ->\n      let (step, os1, st1) = (step_expansion \n  dict_Os_OS_a (s0, exp_state)) in\n      (match st1 with\n        | ExpError err -> expansion_error \n  dict_Os_OS_a true (* may exit *) os1 (XSFor \"arg expansion\") step err\n        | ExpDone f ->\n           (XSFor \"arguments fully expanded\",\n            os1,\n            ForExpanded( var, f, body))\n        | (_ as in_progress) ->\n           (XSExpand( (XSFor \"argument expansion step\"), step),\n            os1,\n            ForExpArgs( var, in_progress, body))\n      )\n  (* FOR: Special case, no items exit status is zero **************************)\n  | ForExpanded( _var, [], _body) ->\n     check_traps dict_Os_OS_a\n       (XSFor \"no items, exit code is 0\", \n        exit_with 0 s0, \n        Done)\n  | ForExpanded( var, (i::f), body) ->\n     (match set_param \n  dict_Os_OS_a var i s0 with\n     | Either.Left err -> (XSFor err, \n                    fail_with \n  dict_Os_OS_a (\"for: \" ^ err) s0,\n                    (if is_interactive s0 then Done else Exit))\n     | Either.Right s1 ->\n        let s2 = (enter_loop s1) in\n        (XSFor (\"starting for loop with \" ^ (var ^ (\" = \" ^ (string_of_symbolic_string i)))),\n         s2, \n         ForRunning( var, f, body, body))\n     )\n  | ForRunning( var, f, body, cur) ->\n     let continue s0 step msg i f'=\n        ((match set_param \n  dict_Os_OS_a var i s0 with\n       | Either.Left err ->\n          (XSNested( (XSFor err), step),\n           fail_with dict_Os_OS_a (\"for: \" ^ err) s0,\n           (if is_interactive s0 then Done else Exit))\n       | Either.Right s1 ->\n          (XSNested( \n             (XSFor \n                (msg ^ (\" to next iteration with \" ^ (var ^ (\" = \" ^ \n                   string_of_symbolic_string i))))), \n             step),\n           s1,\n           ForRunning( var, f', body, body))\n     ))\n     in\n     let (step, s1, cur') = (step_eval \n  dict_Os_OS_a s0 checked cur) in\n     (match cur' with\n     | Exit       -> (XSNested( (XSFor \"exiting\"), step), s1, Exit)\n     | Return     -> (XSNested( (XSFor \"returning\"), step), s1, Return)\n     | Break 1    -> (XSNested( (XSFor \"breaking loop\"), step), exit_loop s1, Done)\n     | Break n    -> (XSNested( (XSFor \"breaking to outer loop\"), step), exit_loop s1, Break (Nat_num.nat_monus n 1))\n     | Continue 1 ->\n        (match f with\n        | [] -> (XSNested( (XSFor \"continued at last iteration\"), step), exit_loop s1, Done)\n        | (i::f') -> continue s1 step \"continuing\" i f'\n        )\n     | Continue n -> (XSNested( (XSFor \"continuing to outer loop\"), step), s1, Continue (Nat_num.nat_monus n 1))\n     | Done ->\n        check_traps dict_Os_OS_a\n          ((match f with\n           | [] -> (XSNested( (XSFor \"finished last iteration\"), step), exit_loop s1, Done)\n           | (i::f') -> continue s1 step \"stepping\" i f'\n           ))\n     | _ -> (XSNested( (XSFor \"\"), step), s1, ForRunning( var, f, body, cur'))\n     )\n\n  (* CASE *********************************************************************)\n  | Case( ws, cases) -> (XSCase \"begin arg expansion\", s0, CaseExpArg( (ExpStart( { splitting = NoSplit; globbing = false }, ws)), cases))\n  | CaseExpArg( exp_state, cases) ->\n      let (step, os1, st1) = (step_expansion \n  dict_Os_OS_a (s0, exp_state)) in\n      (match st1 with\n        | ExpError err -> expansion_error \n  dict_Os_OS_a true (* may exit *) os1 (XSCase \"arg expansion\") step err\n        | ExpExpand( _opts, ew, []) ->\n        (* \"...matched by the string resulting from the tilde\n           expansion, parameter expansion, command substitution,\n           arithmetic expansion, and quote removal of the given word.\" *)\n           let ss = (symbolic_string_of_expanded_words false (* not for pattern *) ew) in\n           (XSCase \"argument fully expanded\", os1, CaseMatch( ss, cases))\n        | (_ as in_progress) ->\n           (XSExpand( (XSCase \"argument expansion step\"), step),\n            os1,\n            CaseExpArg( in_progress, cases))\n      )\n  | CaseMatch( f, cases) ->\n      (match cases with\n        | [] ->\n           check_traps \n  dict_Os_OS_a (XSCase \"no match in case statement\", exit_with 0 s0, Done)\n        | ([], _cmd)::cases' ->\n           (XSCase \"exhausted patterns, checking next case\",\n            s0,\n            CaseMatch( f, cases'))\n        | (pat::pats', cmd1)::cases' ->\n           (XSCase \"checking pattern match\",\n            s0,\n            CaseCheckMatch( f, (ExpStart( { splitting = NoSplit; globbing = false }, pat)), cmd1, ((pats',cmd1)::cases')))\n      )\n  | CaseCheckMatch( f, pat, cmd1, cases) ->\n      let (step, os1, st1) = (step_expansion \n  dict_Os_OS_a (s0, pat)) in\n      (match st1 with\n        | ExpError err -> expansion_error \n  dict_Os_OS_a true (* may exit *) os1 (XSCase \"error in argument expansion\") step err\n        | ExpExpand( _opts, ew, []) ->\n           (* \"each pattern that labels a compound-list shall be\n              subjected to tilde expansion, parameter expansion,\n              command substitution, and arithmetic expansion\" ...\n            *)\n           (* TODO 2018-08-29 use proper locale *)\n           let pat' = (symbolic_string_of_expanded_words true (* for pattern *) ew) in\n           (match match_exact lc_ambient pat' f with\n           | NoMatch -> (XSCase \"case did not match, trying the next\",\n                         os1, CaseMatch( f, cases))\n           | Match _ -> check_traps \n  dict_Os_OS_a  (XSCase \"case matched, evaluating cmd\", os1, cmd1)\n           | Symbolic -> (XSCase \"case on symbolic value, gave up\", fail_with \n  dict_Os_OS_a \"case: symbolic match, giving up\" os1, Done)\n           )\n        | (_ as in_progress) ->\n           (XSExpand( (XSCase \"pattern expansion step\"), step),\n            os1,\n            CaseCheckMatch( f, in_progress, cmd1, cases))\n      )\n\n  (* DEFUN ********************************************************************)\n  | Defun( name1, body) -> \n     if is_special_builtin name1\n     then \n       let msg = (\"invalid function name \" ^ (name1 ^ \" (shadows special built-in)\")) in\n       (XSDefun msg, fail_with \n  dict_Os_OS_a msg s0, (if is_interactive s0 then Done else Exit))\n     else \n       let s1 =\n         (if Pset.mem Sh_earlyhash s0.sh.opts\n         then early_hash \n  dict_Os_OS_a s0 body\n         else s0)\n       in\n       check_traps dict_Os_OS_a (XSDefun (\"defined \" ^ name1), defun name1 body (exit_with 0 s1), Done)\n\n  (* CALL *********************************************************************)\n  | Call( old_loop_nest, old_positional_params, f, orig, c) ->\n     let cleanup os=\n        (let (os', _) = (pop_locals os) in\n       set_function_params old_loop_nest old_positional_params os')\n     in\n     let (step, s1, c') = (step_eval \n  dict_Os_OS_a s0 checked c) in\n     (match c' with\n     | Done   -> check_traps \n  dict_Os_OS_a (XSStack( (f ^ \": implicit return\"), step), cleanup s1, Done)\n     | Return -> check_traps \n  dict_Os_OS_a (XSStack( (f ^ \": explicit return\"), step), cleanup s1, Done)\n     | Exit -> (XSStack( (f ^ \": exit\"), step), cleanup s1, Exit)\n     (* what do we do if there's a break or continue in a call? \n        \n        CURRENT SETUP\n\n        - lexical control (default, set +o nonlexicalctrl)\n\n          `builtin_{break,command}` won't generate breaks without an appropriate loop   \n          nest. these cases never occur.\n\n        - non-lexical control (set -o nonlexicalctrl)\n\n          no checks. behave like bash.\n\n        assertions check the invariant. in either case, it's the builtin's \n        responsibility to log the unspec behavior.\n      *)\n     | Break n ->\n        let _ = (Lem_assert_extra.ensure (Pset.mem Sh_nonlexicalctrl s1.sh.opts)\n                  \"non-lexical break without -o nonlexicalctrl\") in\n        let s2 = (cleanup s1) in\n        (XSStack( (f ^ \": break [unspecified behavior]\"), step),\n         s2,\n         Break n)\n     | Continue n ->\n        let _ = (Lem_assert_extra.ensure (Pset.mem Sh_nonlexicalctrl s1.sh.opts)\n                  \"non-lexical continue without -o nonlexicalctrl\") in\n        let s2 = (cleanup s1) in\n        (XSStack( (f ^ \": continue [unspecified behavior]\"), step),\n         s2,\n         Continue n)\n     | _ ->\n        (XSStack( f, step),\n         s1,\n         Call( old_loop_nest, old_positional_params, f, orig, c'))\n     )\n\n  (* EVALLOOP *****************************************************************)\n\n  | EvalLoop( linno, (((sstr,stackmark1) as ctx)), src, interactive, shell_level1) ->\n     (* INVARIANT: you must call parse_cleanup sstr if you're leaving the eval loop *)\n     let s1 = (show_changed_jobs \n  dict_Os_OS_a DeleteJobs Sh_monitor s0) in\n     let (s2, parsed) = (parse_next \n  dict_Os_OS_a s1 interactive stackmark1) in\n     check_traps dict_Os_OS_a\n       ((match parsed with\n        | ParseDone -> \n           let (s3, c) = \n             (if is_interactive_mode interactive && \n                  (is_toplevel shell_level1 && Pset.mem Sh_ignoreeof s2.sh.opts)\n             then (write_stderr \n  dict_Os_OS_a \"Use \\\"exit\\\" to leave the shell.\\n\" s2, \n                   EvalLoop( linno, ctx, src, interactive, shell_level1))\n             else \n               let _ = (parse_cleanup sstr shell_level1) in\n               (s2, Done))\n           in\n           (XSEval( linno, src, \"done\"), s3, c)\n        | ParseError -> \n           let s3 = (exit_with 2 s2) in\n           let c' =\n             (if is_interactive_mode interactive && is_toplevel shell_level1 \n             then EvalLoop( linno, ctx, src, interactive, shell_level1)\n             else \n               let _ = (parse_cleanup sstr shell_level1) in\n               let catching_errors = (not (checked_exit checked) && \n                                       Pset.mem Sh_errexit s1.sh.opts) in\n               let exit_on_error = (catching_errors || not (is_interactive s3)) in\n               if exit_on_error\n               then Exit\n               else Done)                  \n           in \n           (XSEval( linno, src, \"parse error\"), s3, c')\n        | ParseNull ->\n           (XSEval( linno, src, \"empty line\"), s2, \n            EvalLoop( (linno+1), ctx, src, interactive, shell_level1))\n        | ParseStmt c ->\n           (* TODO 2019-07-10 adding the parsed command to the history should be fine\n              but may be surprising to people! ideal to put in the original string *)\n           let s3 = \n             (if is_interactive_mode interactive && is_toplevel shell_level1\n             then add_to_history c s2\n             else s2)\n           in\n           (XSEval( linno, src, \"\"), s3,\n            EvalLoopCmd( (linno+1), ctx, src, interactive, shell_level1, c))\n        ))\n  | EvalLoopCmd( linno, (((sstr,_stackmark) as ctx)), src, interactive, shell_level1, c) ->\n     (* INVARIANT: you must call parse_cleanup sstr shell_level if you're leaving the eval loop *)\n     let (step, s1, c') = (step_eval \n  dict_Os_OS_a s0 checked c) in\n     (match c' with\n     | Exit -> \n        let _ = (parse_cleanup sstr shell_level1) in \n        (step, s1, Exit)\n     | Done -> \n        (step, s1, EvalLoop( linno, ctx, src, interactive, shell_level1))\n     | Return ->\n        let (step', c') =\n          (if is_toplevel shell_level1\n          then (XSNested( (XSEval( linno, src, \"return at top level\")), step),\n                EvalLoop( linno, ctx, src, interactive, shell_level1))\n          else \n            let _ = (parse_cleanup sstr shell_level1) in\n            if parse_source_for_dot src\n            then (XSNested( (XSEval( linno, src, \"return from dot\")), step),\n                  Done)\n            else (XSNested( (XSEval( linno, src, \"return in eval loop\")), step),\n                  Return))\n        in\n        (step', s1, c')\n     | _ ->\n        if is_terminating_control c' (* Exit, Done, Return already ruled out *)\n        then\n          (* we got some kind of terminating control other than Exit *)\n          check_traps \n  dict_Os_OS_a\n            (XSNested( (XSEval( linno, src, \"returning to loop\")), step),\n             s1, \n             (if not (is_toplevel shell_level1) && parse_source_propagates_control src\n             then\n               (* when break/continue occur in an eval, allow it! *)\n               let _ = (parse_cleanup sstr shell_level1) in\n               c'\n             else \n               (* when they occur at the toplevel or in dot, ignore them *)\n               EvalLoop( linno, ctx, src, interactive, shell_level1)))\n        else \n          (* keep on running *)\n          (XSNested( (XSEval( linno, src, \"\")), step), s1, \n           EvalLoopCmd( linno, ctx, src, interactive, shell_level1, c'))\n     )\n\n  (* EXEC *********************************************************************)\n  | Exec( cmd1, argv0, args, env1, binsh) ->\n     (* INVARIANT: we should have called check_execve before generating an Exec *)\n     (* we'll only actually return if we're running symbolically.\n        with real OS calls, that execve never comes back! *)\n     let (s1, res) = (execve \n  dict_Os_OS_a s0 cmd1 argv0 args env1 binsh) in\n     let msg =\n       ((match res with\n       | Either.Left msg    -> msg\n       | Either.Right _stmt -> \"symbolic execve unimplemented\"\n       ))\n     in\n     (XSExec msg, fail_with \n  dict_Os_OS_a msg s1, (if is_interactive s1 then Done else Exit))\n\n  (* WAIT *********************************************************************)\n  | Wait( n, _checked, (Some 0), _mode) -> (* out of steps *)\n     check_traps dict_Os_OS_a\n       (XSWait (\"stopped blocking on process with pid \" ^ string_of_int n),\n        s0,\n        Done)\n   \n  | Wait( pid1, checking, bound, mode) -> \n     let exit_on_error = (not (checked_exit checking) && Pset.mem Sh_errexit s0.sh.opts) in\n     let s_pid = (string_of_int pid1) in\n     (match wait_for_pid \n  dict_Os_OS_a  (step_eval dict_Os_OS_a) s0 pid1 with\n     | (s1, None) -> \n        check_traps dict_Os_OS_a\n          (XSWait (\"couldn't step process with pid \" ^ s_pid), \n           (if from_wait_command mode\n           then safe_write_stderr \n  dict_Os_OS_a (\"wait: pid \" ^ (s_pid ^ \" is not a child of this shell\\n\")) s1\n           else s1), \n           Done)\n     | (s1, Some (Either.Left step)) ->\n        (* we took a step, so record it *)\n        let bound' = \n          ((match bound with\n          | None -> None\n          | Some n -> Some ( Nat_num.nat_monus n 1)\n          ))\n        in\n        (XSNested( (XSWait (\"process with pid \" ^ (s_pid ^ \" stepped\"))), step),\n         s1,\n         Wait( pid1, checking, bound', mode))\n     | (s1, Some (Either.Right code)) ->\n        let s2 = (delete_job_with_pid s1 pid1) in\n        check_traps dict_Os_OS_a\n          (XSWait (\"process with pid \" ^ (s_pid ^ (\" completed with code \" ^ string_of_int code))),\n           exit_with code s2,\n           (if exit_on_error && not (code = 0)\n           then Exit\n           else Done))\n     )            \n\n  (* TRAPPED ******************************************************************)\n  | Trapped( signal1, old_ec, c_handler, c_cont) ->\n     if is_terminating_control c_handler\n     then \n       let (s1, c) =\n         (if c_handler = Exit\n         then (s0, Exit) (* don't restore old exit code! *)\n         else (exit_with old_ec s0, c_cont))\n       in\n       (XSTrap( signal1, \"finished\"),\n        s1,\n        c)\n     else \n       let (step, s1, c_handler') = (step_eval \n  dict_Os_OS_a s0 Unchecked c_handler) in\n       (XSNested( (XSTrap( signal1, \"\")), step),\n        s1,\n        Trapped( signal1, old_ec, c_handler', c_cont))\n\n  (* CHECKEDEXIT **************************************************************)\n\n  | CheckedExit c ->\n     if is_terminating_control c\n     then check_traps \n  dict_Os_OS_a (XSSubshell \"\", s0, c)\n     else\n       let (step, s1, c') = (step_eval \n  dict_Os_OS_a s0 Checked c) in\n       (XSNested( (XSSubshell \"disable errexit\"), step), \n        s1, \n        CheckedExit c')\n\n  (* PUSHREDIR ****************************************************************)\n  | Pushredir( c, saved_fds1) ->\n     if is_terminating_control c\n     then check_traps \n  dict_Os_OS_a\n            (XSRedir \"popping redirects\", \n             restore_fds \n  dict_Os_OS_a s0 saved_fds1, \n             c)\n     else \n       let (step, s1, c') = (step_eval \n  dict_Os_OS_a s0 checked c) in\n       (XSNested( (XSRedir \"\"), step), \n        s1, \n        Pushredir( c', saved_fds1))\n\n  (* BREAK/CONTINUE/RETURN/EXIT/DONE ******************************************)\n  | Break _n -> check_traps \n  dict_Os_OS_a (XSSimple \"break bottomed out\", s0, Done)\n  | Continue _n -> check_traps \n  dict_Os_OS_a (XSSimple \"continue bottomed out\", s0, Done)\n  | Return -> check_traps \n  dict_Os_OS_a (XSSimple \"return bottomed out\", s0, Done)\n  | Exit -> \n     let (s1,m_cmd) = (exit_trap s0) in\n     (match m_cmd with\n     | None -> (XSSimple \"exited\", exit \n  dict_Os_OS_a s1, Done)\n     | Some cmd1 -> (XSSimple \"trapped on exit\", s1, Semi( cmd1, Exit))\n     )\n  | Done -> check_traps \n  dict_Os_OS_a (XSSimple \"\", s0, Done)\n  ))\n\n(* Evaluation **********************************************************)\n\nand full_evaluation dict_Os_OS_a os0 stmt0:'a os_state=\n   (if out_of_fuel os0\n  then os0\n  else \n    let os1 = (tick dict_Os_OS_a os0) in\n    (match stmt0 with\n    | Done -> os1\n    | _ -> \n       let (step, os2, stmt1) = (step_eval \n  dict_Os_OS_a os1 Unchecked stmt0) in\n       full_evaluation \n  dict_Os_OS_a (log_step step os2) stmt1\n    ))\n\nand eval dict_Os_OS_a os0 stmt0:int=\n   (let os1 = (full_evaluation \n  dict_Os_OS_a os0 stmt0) in\n  let os2 = (full_evaluation \n  dict_Os_OS_a os1 Exit) in\n  os2.sh.exit_code)\n\n(**********************************************************************)   \n(* TRACING ************************************************************)   \n(**********************************************************************)   \n(* These functions are for testing and the expansion tool. *)\n\nopen Os_symbolic\n\n(* Expansion **********************************************************) \n(* unbounded functions for testing final expansion results (used in\n   test_expansion.ml)\n\n   this function is a little unfaithful to the expansion semantics\n   because we're not keeping track of whether the result was a message\n   printed to stderr or the actual result of expansion\n *)\n(*val symbolic_run_full_expansion \n    : os_state symbolic -> expansion_state -> os_state symbolic * fields*)\nlet rec symbolic_run_full_expansion os0 st0:(symbolic)os_state*(symbolic_string)list=\n   ((match st0 with\n  | ExpError f -> (os0, f)\n  | ExpDone f -> (os0, f)\n  | _ -> \n     let (_step,os1,st1) = (step_expansion \n  instance_Os_OS_Os_symbolic_symbolic_dict (os0,st0)) in\n     symbolic_run_full_expansion os1 st1\n  ))\n\n(*val symbolic_full_expansion \n    : os_state symbolic -> words -> os_state symbolic * fields*)\nlet symbolic_full_expansion s0 w0:(symbolic)os_state*fields=  (symbolic_run_full_expansion s0 (ExpStart( { splitting = Split; globbing = true }, w0)))\n   \n(* Tracing evaluation *************************************************)\n(* used in expand.ml *)\n\n(*val try_step_pid : os_state symbolic -> pid -> os_state symbolic * maybe evaluation_step*)\nlet try_step_pid os0 pid1:(symbolic)os_state*(evaluation_step)option=\n   (let (os1, res) = (symbolic_step_pid  \n  (step_eval instance_Os_OS_Os_symbolic_symbolic_dict) os0 pid1) in\n  (match res with\n  | None -> (os1, None)\n  | Some (Either.Right _ec) -> (os1, None)\n  | Some (Either.Left step) -> (os1, Some step)\n  ))\n   \n(*val try_step_all_loop : os_state symbolic -> pid (* current *) -> pid (* up to, exclusive *) -> list (maybe evaluation_step) -> os_state symbolic * list (maybe evaluation_step)*)\nlet rec try_step_all_loop os0 pid1 max_pid steps:(symbolic)os_state*((evaluation_step)option)list=\n   (if pid1 >= max_pid\n  then (os0, List.rev steps)\n  else\n    let (os1, res) = (symbolic_step_pid  \n  (step_eval instance_Os_OS_Os_symbolic_symbolic_dict) os0 pid1) in\n    let step = \n      ((match res with\n      | None -> None\n      | Some (Either.Right _ec) -> None\n      | Some (Either.Left step) -> \n         Some step\n      ))\n     in\n     try_step_all_loop os1 (pid1 + 1) max_pid (step::steps))\n\nlet try_step_all os0:(symbolic)os_state*((evaluation_step)option)list=\n   (try_step_all_loop os0 0 (List.length os0.symbolic.procs) []) \n     \nlet rec run_trace_evaluation_loop os0:(evaluation_step*shell_state*symbolic*stmt)list*(symbolic)os_state=\n   (if out_of_fuel os0\n  then ([(XSStep \"out of fuel\", os0.sh, os0.symbolic, proc_stmt os0 0)], os0)\n  else \n    let os1 = (tick instance_Os_OS_Os_symbolic_symbolic_dict os0) in\n    let (os2, steps) = (try_step_all os1) in\n    (* make sure we're back in pid 0, the root shell *)\n    let (os3, _sproc) = (proc_select os2 0) in\n    if List.for_all Lem.is_none steps\n    then ([], os3)\n    else let m_step0 = (List.hd steps) in\n         let step0 = ((match m_step0 with\n           | None -> XSSimple \"no step in root shell\"\n           | Some step -> step \n           ))\n         in\n         let entry1 = (step0, os3.sh, os3.symbolic, proc_stmt os3 0) in\n         let (trace,os4) = (run_trace_evaluation_loop os2) in\n         ((entry1::trace), os4))\n\n(*val run_trace_evaluation : os_state symbolic -> stmt -> evaluation_trace*)\nlet run_trace_evaluation os0 stmt1:(evaluation_step*shell_state*symbolic*stmt)list*(symbolic)os_state=\n   (let os1 = (proc_set_stmt os0 0 stmt1) in\n  run_trace_evaluation_loop os1)\n\n(*val symbolic_full_evaluation : os_state symbolic -> stmt -> os_state symbolic*)\nlet symbolic_full_evaluation s0 c:(symbolic)os_state=  (snd (run_trace_evaluation s0 c))\n\n(* Real evaluation ****************************************************)\n(* convenience functions for shell.ml *)\nopen Os_system\n\n(*val real_eval : os_state system -> stmt -> os_state system*)\nlet real_eval:(unit)os_state ->stmt ->(unit)os_state= \n  (full_evaluation instance_Os_OS_unit_dict)\n\n(*val real_eval_for_exit_code : os_state system -> stmt -> nat*)\nlet real_eval_for_exit_code:(unit)os_state ->stmt ->int= \n  (eval instance_Os_OS_unit_dict)\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00596046447754ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0131130218506ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":12,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.00715255737305ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":114,"character":4},"end":{"line":114,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0209808349609ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":113,"character":20},"end":{"line":113,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0240802764893ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":41}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":47}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":46}}}
[server] Got a method textDocument/hover
[server] processing took 0.028133392334ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":47}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":113,"character":47},"end":{"line":113,"character":47}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":54}}}
[server] Got a method textDocument/hover
[server] processing took 0.018835067749ms
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":54}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0388622283936ms
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":113,"character":54},"end":{"line":113,"character":54}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0200271606445ms
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":62}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0109672546387ms
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":113,"character":62},"end":{"line":113,"character":62}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":73}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":74}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":75}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"range":{"start":{"line":113,"character":75},"end":{"line":113,"character":75}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":76}}}
[server] Got a method textDocument/hover
[server] processing took 0.0128746032715ms
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":113,"character":76}}}
[server] Got a method textDocument/hover
[server] processing took 0.0219345092773ms
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"},"position":{"line":119,"character":6}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/semantics.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml","languageId":"ocaml","version":1,"text":"(*Generated by Lem from smoosh_num.lem.*)\nopen Lem_pervasives_extra\n(*import Debug*)\n\n(*--------------------------------*)\n(* Nat class                      *)\n(*--------------------------------*)\ntype 'a nat_class= {\n  fromNat_method : int -> 'a;\n  toNat_method : 'a -> int\n}\n\nlet instance_Smoosh_num_Nat_Num_integer_dict:(Nat_big_num.num)nat_class= ({\n\n  fromNat_method = Nat_big_num.of_int;\n\n  toNat_method = (fun n->abs (Nat_big_num.to_int n))})\n\nlet instance_Smoosh_num_Nat_Num_int32_dict:(Int32.t)nat_class= ({\n\n  fromNat_method = Int32.of_int;\n\n  toNat_method = (fun i->abs (Nat_big_num.to_int (Nat_big_num.of_int32 i)))})\n\nlet instance_Smoosh_num_Nat_Num_int64_dict:(Int64.t)nat_class= ({\n\n  fromNat_method = Int64.of_int;\n\n  toNat_method = (fun i->abs (Nat_big_num.to_int (Nat_big_num.of_int64 i)))})\n\n(*val has_bit : nat -> nat -> bool*)\nlet has_bit n bit:bool=  (((n / ( natPow 2 bit)) mod 2) = 1)\n\n(*--------------------------------*)\n(* Read class                     *)\n(*--------------------------------*)\n\nlet is_whitespace c:bool=  (elem \n  instance_Basic_classes_Eq_char_dict c (Xstring.explode \" \\n\\t\"))\nlet is_digit c:bool=  (elem \n  instance_Basic_classes_Eq_char_dict c (Xstring.explode \"1234567890\"))\nlet is_octal_digit c:bool=  (elem \n  instance_Basic_classes_Eq_char_dict c (Xstring.explode \"01234567\"))\nlet is_num_const_char c:bool=  (elem \n  instance_Basic_classes_Eq_char_dict c (Xstring.explode \"1234567890xabcdefABCDEF\"))\n\n(*val is_numeric : list char -> bool*)\nlet is_numeric:(char)list ->bool=  ((fun l->List.fold_right (fun c ok -> is_num_const_char c && ok) l true))\n\n(* Convert uppercase A-F to lowercase and then convert\n * lowercase hexdigit to integer 10 to 15. *)\n(*val hexalpha_to_num : char -> either string nat*)\nlet hexalpha_to_num c:((string),(int))Either.either=\n   ((match c with\n  | '0' -> Either.Right 0\n  | '1' -> Either.Right 1\n  | '2' -> Either.Right 2\n  | '3' -> Either.Right 3\n  | '4' -> Either.Right 4\n  | '5' -> Either.Right 5\n  | '6' -> Either.Right 6\n  | '7' -> Either.Right 7\n  | '8' -> Either.Right 8\n  | '9' -> Either.Right 9\n  | 'a' -> Either.Right 10\n  | 'b' -> Either.Right 11\n  | 'c' -> Either.Right 12\n  | 'd' -> Either.Right 13\n  | 'e' -> Either.Right 14\n  | 'f' -> Either.Right 15\n  | 'A' -> Either.Right 10\n  | 'B' -> Either.Right 11\n  | 'C' -> Either.Right 12\n  | 'D' -> Either.Right 13\n  | 'E' -> Either.Right 14\n  | 'F' -> Either.Right 15\n  | _ -> Either.Left (\"bad digit '\" ^ (Xstring.implode [c] ^ \"'\"))\n  ))\n\ntype 'a read_class= {\n  (* Read can fail with an error message by using Left.\n   * Do not use any methods that may throw errors. *)\n  read_method : char list -> (string, 'a) Either.either;\n  write_method : 'a -> string\n}\n\n(*val trim : list char -> list char*)\nlet trim cs:(char)list= \n   (let ltrim = (Lem_list.dropWhile is_whitespace cs) in\n  let rtrim_rev = (Lem_list.dropWhile is_whitespace (List.rev ltrim)) in\n  List.rev rtrim_rev)\n\nlet rec readConstant dict_Num_NumNegate_b dec hex oct chars:('a,'b)Either.either=\n   (let cs = (trim chars) in\n  let (negative, cs') =\n    ((match cs with\n    | '-'::cs' -> (true, cs')\n    | '+'::cs' -> (false, cs')\n    | _         -> (false, cs)\n    ))\n  in\n  let res = \n    ((match cs' with\n    | ['0'] -> dec cs' (* doesn't matter *)\n    | '0'::'x'::cs'' -> hex cs''\n    | '0'::cs'' -> oct cs''\n    | _ -> dec cs'\n    ))\n  in\n  if negative\n  then (match res with\n       | Either.Left msg -> Either.Left msg\n       | Either.Right n -> Either.Right (\n  dict_Num_NumNegate_b.numNegate_method n)\n       )\n  else res)\n\nlet int64Max:Int64.t=  (Int64.sub ( int64Pow(Int64.of_int 2) 63)(Int64.of_int (Nat_big_num.of_int 1)))\nlet int64Min:Int64.t=  (Int64.neg( int64Pow(Int64.of_int 2) 63))\n\nlet int32Max:Int32.t=  (Int32.sub ( int32Pow(Int32.of_int 2) 31)(Int32.of_int (Nat_big_num.of_int 1)))\nlet int32Min:Int32.t=  (Int32.neg( int32Pow(Int32.of_int 2) 31))\n\n(*val unbounded_unsigned : nat (* bits *) -> integer -> integer*)\nlet unbounded_unsigned bits unbounded_n:Nat_big_num.num= \n   (let signed_bits = (Nat_num.nat_monus bits 1) in\n  let upper = (Nat_big_num.sub  ( Nat_big_num.pow_int(Nat_big_num.of_int 2) signed_bits)(Nat_big_num.of_int (Nat_big_num.of_int 1))) in\n  let lower = (Nat_big_num.negate( Nat_big_num.pow_int(Nat_big_num.of_int 2) signed_bits))     in\n  (* first, bound it *)\n  let n = (if Nat_big_num.less unbounded_n lower then lower \n          else if Nat_big_num.greater unbounded_n upper then upper\n          else unbounded_n) in\n  (* then set up the two's complement for negatives *)\n  if Nat_big_num.less n(Nat_big_num.of_int (Nat_big_num.of_int 0))\n  then Nat_big_num.add ( Nat_big_num.pow_int(Nat_big_num.of_int 2) bits) n\n  else n)\n\n(*val unbounded_unsigned64 : integer -> integer*)\nlet unbounded_unsigned64:Nat_big_num.num ->Nat_big_num.num=  (unbounded_unsigned 64)\n\n(*val readInteger_loop : nat -> integer -> (list char) -> either string integer*)\nlet rec readInteger_loop base acc chars:((string),(Nat_big_num.num))Either.either=\n   ((match chars with\n  | [] -> Either.Right acc\n  | (c::cs) ->\n     (match hexalpha_to_num c with\n     | Either.Left msg -> Either.Left msg\n     | Either.Right num ->\n        if (num > Nat_num.nat_monus base 1) || (num < 0)\n        then Either.Left ((Xstring.implode [c]) ^ (\" is not a valid base \" ^ (string_of_int base ^ \" digit\")))\n        else readInteger_loop base ( Nat_big_num.add( Nat_big_num.mul(Nat_big_num.of_int base) acc) (Nat_big_num.of_int num)) cs\n     )\n  ))\n\n(*val readUnsignedInteger : nat -> list char -> either string integer*)\nlet readUnsignedInteger base chars:((string),(Nat_big_num.num))Either.either=\n   ((match chars with\n  | [] -> Either.Left \"empty string is not numeric\"\n  | _ -> readInteger_loop base(Nat_big_num.of_int (Nat_big_num.of_int 0)) chars\n  ))\n\n(*val readSignedInteger : nat -> list char -> either string integer*)\nlet readSignedInteger base chars:((string),(Nat_big_num.num))Either.either=\n   (let chars = (trim chars) in\n  (match chars with\n  | '+'::cs -> readUnsignedInteger base cs\n  | '-'::cs ->\n     (match readUnsignedInteger base cs with\n     | Either.Left msg -> Either.Left msg\n     | Either.Right n -> Either.Right (Nat_big_num.negate n)\n     )\n  | _ -> readUnsignedInteger base chars\n  ))        \n  \n(*val system_int_size : nat*)\n\n(* computed carefully to avoid overflow *)\n(*val highestNat : nat*)\nlet highestNat:int=  (Nat_num.nat_monus (natPow 2 ( Nat_num.nat_monus Sys.int_size 2)) 1 + natPow 2 ( Nat_num.nat_monus Sys.int_size 2))\n\n(* only use this for base 10 literals *)\n(*val readNat : (list char) -> either string nat*)\nlet readNat cs:((string),(int))Either.either=\n   (let cs = (trim cs) in\n  if is_numeric cs\n  then (match readUnsignedInteger 10 cs with\n       | Either.Right n -> \n          if Nat_big_num.greater n (Nat_big_num.of_int (highestNat))\n          then Either.Right highestNat\n          else Either.Right (abs (Nat_big_num.to_int n))\n       | Either.Left e -> Either.Left e\n       )\n  else Either.Left (Xstring.implode cs ^ \" is non-numeric\"))\n\n(*val parse_nat : list char -> either string (nat * list char)*)\nlet parse_nat cs:((string),(int*(char)list))Either.either=\n   ((match splitWhile is_digit cs with\n  | ([],_) -> Either.Left \"no digits\"\n  | (ds,rest) ->\n     (match readNat ds with\n     | Either.Left msg -> Either.Left msg\n     | Either.Right n -> Either.Right (n,rest)\n     )\n  ))\n\n(*val readInt64_loop : nat -> int64 -> (list char) -> either string int64*)\nlet rec readInt64_loop base acc chars:((string),(Int64.t))Either.either=\n   ((match chars with\n  | [] -> Either.Right acc\n  | (c::cs) ->\n     (match hexalpha_to_num c with\n     | Either.Left msg -> Either.Left msg\n     | Either.Right num ->\n       if (num > Nat_num.nat_monus base 1) || (num < 0)\n       then Either.Left ((Xstring.implode [c]) ^ (\" is not a valid base \" ^ (string_of_int base ^ \" digit\")))\n       else let acc1 = (Int64.add ( Int64.mul(Int64.of_int base) acc) (Int64.of_int num)) in\n            if acc1 <Int64.of_int (Nat_big_num.of_int 0)\n            then Either.Right int64Max\n            else readInt64_loop base acc1 cs\n     )\n  ))\n\n(*val readInt64 : nat -> (list char) -> either string int64*)\nlet readInt64 base chars:((string),(Int64.t))Either.either=\n   ((match chars with\n  | [] -> Either.Left \"empty string is not numeric\"\n  | _ -> readInt64_loop base (Int64.of_int 0) chars\n  ))\n\n(*val readInt32_loop : nat -> int32 -> (list char) -> either string int32*)\nlet rec readInt32_loop base acc chars:((string),(Int32.t))Either.either=\n   ((match chars with\n  | [] -> Either.Right acc\n  | (c::cs) ->\n     (match hexalpha_to_num c with\n     | Either.Left msg -> Either.Left msg\n     | Either.Right num ->\n       if (num > Nat_num.nat_monus base 1) || (num < 0)\n       then Either.Left ((Xstring.implode [c]) ^ (\" is not a valid base \" ^ (string_of_int base ^ \" digit\")))\n       else let acc1 = (Int32.add ( Int32.mul(Int32.of_int base) acc) (Int32.of_int num)) in\n            if acc1 <Int32.of_int (Nat_big_num.of_int 0)\n            then Either.Right int32Max\n            else readInt32_loop base acc1 cs\n     )\n  ))\n\n(*val readInt32 : nat -> (list char) -> either string int32*)\nlet readInt32 base chars:((string),(Int32.t))Either.either=\n   ((match chars with\n  | [] -> Either.Left \"empty string is not numeric\"\n  | _ -> readInt32_loop base (Int32.of_int 0) chars\n  ))\n\nlet digits:(char)list=  (Xstring.explode \"0123456789abcdef\")\n\n(*val conv_digit : nat -> string*)\nlet conv_digit n:string=\n   ((match list_index digits n with\n  | None -> failwith \"invalid digit---can only go up to hexadecimal\"\n  | Some c -> Xstring.implode [c]\n  ))\n\n(*val write_helper : forall 'a. Eq 'a, Nat 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a -> string -> 'a -> string*)\nlet rec write_helper dict_Basic_classes_Eq_a dict_Smoosh_num_Nat_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a base str n:string=\n   (let _ = (Lem_assert_extra.ensure (elem \n  instance_Basic_classes_Eq_nat_dict (dict_Smoosh_num_Nat_a.toNat_method base) [2; 8; 10; 16]) \n            \"can only work with binary, octal, decimal, and hexadecimal\") in\n  if  dict_Basic_classes_Eq_a.isEqual_method n (dict_Smoosh_num_Nat_a.fromNat_method 0)\n  then str\n  else let next_digit = (\n  dict_Num_NumRemainder_a.mod_method n base) in\n    write_helper dict_Basic_classes_Eq_a dict_Smoosh_num_Nat_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a base (conv_digit (dict_Smoosh_num_Nat_a.toNat_method next_digit) ^ str) ( \n  dict_Num_NumIntegerDivision_a.div_method n base))\n\n(*val unbounded_write_base : forall 'a. Eq 'a, Ord 'a, Nat 'a, NumNegate 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a (* base *) -> 'a (* num *) -> string*)\nlet unbounded_write dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a base n:string=\n   (if  dict_Basic_classes_Ord_a.isLess_method n (dict_Smoosh_num_Nat_a.fromNat_method 0)\n  then \"-\" ^ (write_helper \n  dict_Basic_classes_Eq_a dict_Smoosh_num_Nat_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a base \"\" (dict_Num_NumNegate_a.numNegate_method n))\n  else \n    if  dict_Basic_classes_Eq_a.isEqual_method n (dict_Smoosh_num_Nat_a.fromNat_method 0)\n    then \"0\"\n    else write_helper \n  dict_Basic_classes_Eq_a dict_Smoosh_num_Nat_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a base \"\" n)\n\n(*val unbounded_write_decimal : forall 'a. Eq 'a, Ord 'a, Nat 'a, NumNegate 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a -> string*)\nlet unbounded_write_decimal dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a n:string=  (unbounded_write \n  dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a (dict_Smoosh_num_Nat_a.fromNat_method 10) n)\n\n(*val unbounded_write_octal : forall 'a. Eq 'a, Ord 'a, Nat 'a, NumNegate 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a -> string*)\nlet unbounded_write_octal dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a n:string=  (unbounded_write \n  dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a (dict_Smoosh_num_Nat_a.fromNat_method 8) n)\n\n(*val unbounded_write_hex : forall 'a. Eq 'a, Ord 'a, Nat 'a, NumNegate 'a, NumIntegerDivision 'a, NumRemainder 'a => 'a -> string*)\nlet unbounded_write_hex dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a n:string=  (unbounded_write \n  dict_Num_NumNegate_a dict_Num_NumIntegerDivision_a dict_Num_NumRemainder_a dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a dict_Smoosh_num_Nat_a (dict_Smoosh_num_Nat_a.fromNat_method 16) n)\n\n(*val write32 : int32 -> string*)\n(*val write64 : int64 -> string*)\n\n(*val unbounded_read : list char -> either string integer*)\nlet unbounded_read cs:((string),(Nat_big_num.num))Either.either= \n   (readConstant instance_Num_NumNegate_Num_integer_dict (readUnsignedInteger 10) (readUnsignedInteger 16) (readUnsignedInteger 8) cs)\n\nlet instance_Smoosh_num_Read_Num_integer_dict:(Nat_big_num.num)read_class= ({\n\n  read_method = unbounded_read;\n\n  write_method = \n  (unbounded_write_decimal instance_Basic_classes_Eq_Num_integer_dict\n     instance_Basic_classes_Ord_Num_integer_dict\n     instance_Smoosh_num_Nat_Num_integer_dict\n     instance_Num_NumNegate_Num_integer_dict\n     instance_Num_NumIntegerDivision_Num_integer_dict\n     instance_Num_NumRemainder_Num_integer_dict)})\n\nlet instance_Smoosh_num_Read_Num_int64_dict:(Int64.t)read_class= ({\n\n  read_method = (fun cs->readConstant \n  instance_Num_NumNegate_Num_int64_dict (readInt64 10) (readInt64 16) (readInt64 8) cs);\n\n  write_method = Int64.to_string})\n\nlet instance_Smoosh_num_Read_Num_int32_dict:(Int32.t)read_class= ({\n\n  read_method = (fun cs->readConstant \n  instance_Num_NumNegate_Num_int32_dict (readInt32 10) (readInt32 16) (readInt32 8) cs);\n\n  write_method = Int32.to_string})\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0529289245605ms
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0150203704834ms
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 28, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"},"position":{"line":14,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"},"position":{"line":59,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0178813934326ms
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"},"position":{"line":60,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/mandalarian/Github/smoosh-macOS/smoosh/src/smoosh_num.ml"}}}
